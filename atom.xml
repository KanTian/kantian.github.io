<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[kantian's Notes]]></title>
  <subtitle><![CDATA[技术是一场修行...]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://fengcode.com//"/>
  <updated>2015-06-20T06:42:01.826Z</updated>
  <id>http://fengcode.com//</id>
  
  <author>
    <name><![CDATA[KanTian]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://fengcode.com/2015/06/24/hello-world/"/>
    <id>http://fengcode.com/2015/06/24/hello-world/</id>
    <published>2015-06-24T02:08:30.116Z</published>
    <updated>2015-06-20T06:42:01.826Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈大端模式和小端模式]]></title>
    <link href="http://fengcode.com/2015/03/05/big-endian-and-little-endian/"/>
    <id>http://fengcode.com/2015/03/05/big-endian-and-little-endian/</id>
    <published>2015-03-05T03:22:33.000Z</published>
    <updated>2015-06-24T10:18:55.024Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>计算机内存中，数据是按照字节进行存储，对应于内存中的每一个字节都有一个地址。如果我们内存想象成一个无比庞大的数组，那么这个数组包含若干个元素，我们通过地址来访问数组中的每一个元素。每一个数组元素占一个字节大小并且存放一个字接大小的内容。</p>
<h2 id="数据在内存中的存放">数据在内存中的存放</h2><p>以32位为例，通常的int型和float型数据都占用32位（bits），也就是4字节（bytes）。每一个内存地址指向的内存单元只能存放1字节(8-bits)，<strong>因此需要把一个占4字节的一个int型数据拆分，存放到4个连续的内存单元中</strong>。比方说,有一个占32位的int型数据(十六进制表示）： k = 0x12345678，拆分后每一个字节对应的部分数据为12,34,56,78。由于<a href="http://en.wikipedia.org/wiki/Endianness#History" target="_blank" rel="external">历史的原因</a>，存在两种不同的字节顺序(endianness)来存放这4个字节——大端字节序（Big-endian）和小端字节序（Little-endian），其在内存中的存放顺序大致分别如下图所示：</p>
<h4 id="大端字节序(Big-endian)">大端字节序(Big-endian)</h4><table>
<thead>
<tr>
<th>地址</th>
<th>数据  </th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>12</td>
</tr>
<tr>
<td>P+1</td>
<td>34</td>
</tr>
<tr>
<td>P+2</td>
<td>56</td>
</tr>
<tr>
<td>P+3</td>
<td>78</td>
</tr>
</tbody>
</table>
<h4 id="小端字节序(Little-endian)">小端字节序(Little-endian)</h4><table>
<thead>
<tr>
<th>地址</th>
<th>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>78</td>
</tr>
<tr>
<td>P+1</td>
<td>56</td>
</tr>
<tr>
<td>P+2</td>
<td>34</td>
</tr>
<tr>
<td>P+3</td>
<td>12</td>
</tr>
</tbody>
</table>
<p><strong>字节序</strong>是一个处理器架构特性，用来指示超过单个字节大小的数据类型（如：int,float,double，etc…)在内存中存储的字节顺序。<br>以上两种字节序的存放顺序是恰好相反的。注意，为了方便记忆，可以理解为：</p>
<blockquote>
<pre><code>大端字节序：  <span class="keyword">*</span>低地址存放数字<span class="keyword">*</span><span class="keyword">*</span>高<span class="keyword">*</span><span class="keyword">*</span>位<span class="keyword">*</span>
小端字节序：  <span class="keyword">*</span>低地址存放数字<span class="keyword">*</span><span class="keyword">*</span>低<span class="keyword">*</span><span class="keyword">*</span>位<span class="keyword">*</span>
</code></pre></blockquote>
<h4 id="常见几个系统的字节序">常见几个系统的字节序</h4><table>
<thead>
<tr>
<th>操作系统</th>
<th>处理器架构</th>
<th>字节序</th>
</tr>
</thead>
<tbody>
<tr>
<td>FreeBSD 5.2.1</td>
<td>Intel Pentium</td>
<td>Little-endian</td>
</tr>
<tr>
<td>Linux 2.4.22</td>
<td>Intel Pentium</td>
<td>Little-endian</td>
</tr>
<tr>
<td>Mac Ox X 10.3</td>
<td>PowerPC</td>
<td>Big-endian</td>
</tr>
<tr>
<td>Solaris 9</td>
<td>Sun SPARC</td>
<td>Big-endian</td>
</tr>
</tbody>
</table>
<h2 id="字节序与编程">字节序与编程</h2><p>通常来说，在同一台计算机上的进程进行通信时，不必考虑字节序。然而在不同计算机之间进行数据传输和存储的时候就必然要考虑不同的计算机的字节序差异了，否则会带来意想不到的结果。<br>不妨看看如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    FILE* fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Our example data structure */</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> one[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span>  two;</span><br><span class="line">        <span class="keyword">char</span> three[<span class="number">4</span>];</span><br><span class="line">    &#125; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill our structure with data */</span></span><br><span class="line">    <span class="built_in">strcpy</span> (data.one, <span class="string">"foo"</span>);</span><br><span class="line">    data.two = <span class="number">0x01234567</span>;</span><br><span class="line">    <span class="built_in">strcpy</span> (data.three, <span class="string">"bar"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write it to a file */</span></span><br><span class="line">    fp = fopen (<span class="string">"output"</span>, <span class="string">"wb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        fwrite (&amp;data, <span class="keyword">sizeof</span> (data), <span class="number">1</span>, fp);</span><br><span class="line">        fclose (fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码把一个结构体data写入到文件output当中。这个结构体包含一个char类型数组（one），一个int型数（two），以及另一个char类型数组（three）。<br>不论在大端字节序还是在小端字节序的机子上都能正常编译和运行，然而当我们通过hexdump工具查看程序输出文件内容的时候，差别就显现出来了。</p>
<ul>
<li><p>在大端字节序（Big-endian）机子下：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span>  66 6f 6f <span class="number">00 12 34 56</span> 78  <span class="number">62 61 72 00</span>     |foo..4Vxbar.|</span><br><span class="line"><span class="number">0000000</span>c</span><br></pre></td></tr></table></figure>
</li>
<li><p>在小端字节序（Little-endian）机子下：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span>  66 6f 6f <span class="number">00 78 56 34</span> 12  <span class="number">62 61 72 00</span>     |foo.xV4.bar.|</span><br><span class="line"><span class="number">0000000</span>c</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可见，在不同的平台上面，对结构体中int类型的数two的存储顺序是不同的。如果处理器只按照各自默然的方式来读取文件的话，文件的内容就并非我们所想象的那样了。</p>
<h4 id="判断机器字节序">判断机器字节序</h4><p>那么,如何通过程序来判断某台机子的字节序呢？且看如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;inttypes.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *ch;</span><br><span class="line">    i = <span class="number">0x04050607</span>;</span><br><span class="line">    ch = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;i;</span><br><span class="line">    <span class="keyword">if</span>(*ch == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"big endian\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*ch == <span class="number">7</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"little endian\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"unknow\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据前文的描述不难理解：只要判断其指针所指的第一个字节的内容即可判定是大端字节序还是小端字节序。<br>1）如果第一个字节（低地址）存放的是整数的低位数字，则为小端字节序（Little-endian)<br>2)如果第一个字节（低地址）存放的是整数的高位数字，则为大端字节序（Big-endian）</p>
<p><strong><em>更进一步，通过宏定义来实现：</em></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> is_big_endian() ((*(unsigned char *)&amp;i)==0)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="字节序转换">字节序转换</h4><p>如何把一个int型数转换为大端字节序呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*System Env:Linux version 3.13.0-43-generic (buildd@akateko) (gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5) )</span><br><span class="line">  Author: kantian</span><br><span class="line">  Date: 2015-01-06 17:01</span><br><span class="line">  Description:Litter-endian int ---&gt; Big-endian int </span><br><span class="line">*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> is_big_endian() ((*(unsigned char*)&amp;i) == 0)</span></span><br><span class="line"><span class="comment">//方法一:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">big_endian_int</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">    <span class="comment">//alread is big-endian,just return i</span></span><br><span class="line">    <span class="keyword">if</span>(is_big_endian())&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get the 1st,2nd,3rd and 4th byte</span></span><br><span class="line">    a = i &amp; <span class="number">255</span>;</span><br><span class="line">    b = (i &gt;&gt; <span class="number">8</span>) &amp; <span class="number">255</span>;</span><br><span class="line">    c = (i &gt;&gt; <span class="number">16</span>) &amp; <span class="number">255</span>;</span><br><span class="line">    d = (i &gt;&gt; <span class="number">24</span>) &amp; <span class="number">255</span>;</span><br><span class="line">    <span class="comment">//combine them in new order</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)((<span class="keyword">int</span>)d + (<span class="keyword">int</span>)(c &lt;&lt; <span class="number">8</span>) + (<span class="keyword">int</span>)(b &lt;&lt;<span class="number">16</span>) + (<span class="keyword">int</span>)(a &lt;&lt; <span class="number">24</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">big_endian_int_2</span><span class="params">(<span class="keyword">char</span> *i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;    </span><br><span class="line">    <span class="keyword">char</span> *b = (<span class="keyword">char</span> *)&amp;a;</span><br><span class="line">    <span class="comment">//for each byte</span></span><br><span class="line">    <span class="keyword">if</span>(is_big_endian())&#123;</span><br><span class="line">       b[<span class="number">0</span>] = i[<span class="number">0</span>];</span><br><span class="line">       b[<span class="number">1</span>] = i[<span class="number">1</span>];</span><br><span class="line">       b[<span class="number">2</span>] = i[<span class="number">2</span>];</span><br><span class="line">       b[<span class="number">3</span>] = i[<span class="number">3</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       b[<span class="number">0</span>] = i[<span class="number">3</span>];</span><br><span class="line">       b[<span class="number">1</span>] = i[<span class="number">2</span>];</span><br><span class="line">       b[<span class="number">2</span>] = i[<span class="number">1</span>];</span><br><span class="line">       b[<span class="number">3</span>] = i[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0x01020304</span>;    </span><br><span class="line">    <span class="keyword">int</span> b = big_endian_int(k);</span><br><span class="line">    <span class="keyword">int</span> c = big_endian_int_2((<span class="keyword">char</span> *)&amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,b);<span class="comment">//04030201</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,c);<span class="comment">//04030201</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="网络和主机间字节序交换">网络和主机间字节序交换</h4><p>如前文所述，不同的计算机进程之间通过网络进行通信的时候，不同的字节序会给其带来麻烦。那么如何来消除不同计算机之间字节序的不同所造成的影响呢？事实上网络协议通常规定了字节序，因此，异构计算机系统能够交换协议信息而不会混淆字节序，如TCP/IP协议就是大端字节序（Big-endian)。对于TCP/IP应用程序，提供了四个通用的程序用来进行本地字节序跟网络字节序之间的转换，如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">//将主机字节序转换为32位网络字节序</span></span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostint32);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将主机字节序转换微16位网络字节序</span></span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostint16);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将网络字节序转换为32位主机字节序</span></span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> hostint32);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将网络字节序转换微16位主机字节序</span></span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> hostint16);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<pre><code>注意，便于记忆：
<span class="string">n:</span>  network 网络
h： host 主机
<span class="string">l:</span>  <span class="typename">long</span> 整型（<span class="number">4</span> bytes) 相对于<span class="typename">short</span>
s： <span class="typename">short</span> 短整型（<span class="number">2</span> bytes) 
</code></pre></blockquote>
<h2 id="问题来了">问题来了</h2><p>下面程序在大端字节序（Big-endian)的机子上和小端字节序(Little-endian)的机子上分别输出什么？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> endian[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">short</span> x;</span><br><span class="line">    x = *(<span class="keyword">short</span> *) endian;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>答案是：</p>
<blockquote>
<pre><code><span class="attribute">Little-endian</span>: <span class="string"> 1</span>
<span class="attribute">Big-endian</span>: <span class="string"> 256</span>
</code></pre></blockquote>
<h2 id="参考文献"> 参考文献</h2><ul>
<li>[1] <a href="http://en.wikipedia.org/w/index.php?title=Endianness" target="_blank" rel="external">http://en.wikipedia.org/w/index.php?title=Endianness</a></li>
<li>[2] <a href="http://www.ibm.com/developerworks/aix/library/au-endianc/index.html" target="_blank" rel="external">http://www.ibm.com/developerworks/aix/library/au-endianc/index.html</a></li>
<li>[3] <a href="http://www.apuebook.com/apue2e.html" target="_blank" rel="external">http://www.apuebook.com/apue2e.html</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>计算机内存中，数据是按照字节进行存储，对应于内存中的每一个字节都有一个地址。如果我们内存想象成一个无比庞大的数组，那么这个数组包含若干个元素，我们通过地址来访问数组中的每一个元素。每一个数组元素占一个字节大小并且存放一个字接大小的内容。]]>
    </summary>
    
      <category term="Linux" scheme="http://fengcode.com/tags/Linux/"/>
    
      <category term="Linux" scheme="http://fengcode.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL 知识点整理三]]></title>
    <link href="http://fengcode.com/2015/02/01/mysql-crash-course-3/"/>
    <id>http://fengcode.com/2015/02/01/mysql-crash-course-3/</id>
    <published>2015-02-01T03:22:02.000Z</published>
    <updated>2015-06-24T10:22:12.265Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>本文接上文<a href="/blog/2015/01/14/mysql-crash-course-1/">MySQL 知识点整理(上)</a>,<a href="/blog/2015/01/14/mysql-crash-course-2/">MySQL 知识点整理(中)</a>.<br>该部分主要梳理了MySQL的视图、存储过程、游标、触发器以及事务处理等。</p>
<h2 id="视图">视图</h2><h4 id="视图简介">视图简介</h4><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用是动态检索数据的查询。<br>为什么使用视图：</p>
<ul>
<li>简化并且重用SQL语句,一次性编写基础SQL语句</li>
<li>封装内部表结构，保护数据</li>
<li>…</li>
</ul>
<p>视图本身不包含数据，在针对视图进行SELECT的操作时，或者对多个视图进行联结时，都会执行视图所封装的查询。<br>因此如果用多个联结和过滤创建了一个复杂的视图时，可能会发现性能大幅下降。</p>
<h4 id="视图的规则和限制">视图的规则和限制</h4><ul>
<li>视图名字唯一</li>
<li>可创建的视图数目没有限制</li>
<li>创建视图需要获取权限</li>
<li>视图可以嵌套</li>
<li>对视图进行SELECT时，如果用到了ORDER BY，那么会覆盖视图内部SELECT中的ORDER BY</li>
<li>视图可以和表一起使用</li>
</ul>
<hr>
<h4 id="创建视图">创建视图</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW productcustomers AS&#10;SELECT cust_name, cust_contact, prod_id&#10;FROM customers, orders, orderitems&#10;WHERE customers.cust_id = orders.cust_id&#10;    AND orderitems.order_num = orders.order_num;</span><br></pre></td></tr></table></figure>
<h4 id="查看视图创建语句">查看视图创建语句</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE VIEW productcustomers;</span><br></pre></td></tr></table></figure>
<h4 id="删除视图">删除视图</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW productcustomers;</span><br></pre></td></tr></table></figure>
<h4 id="修改视图">修改视图</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.&#10;DROP VIEW viewname;&#10;CREATE VIEW ...&#10;&#10;2.&#10;CREATE OR REPLACE VIEW ...</span><br></pre></td></tr></table></figure>
<h4 id="利用视图进行查询">利用视图进行查询</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact&#10;FROM productcustomers&#10;WHERE prod_id = &#39;TNT2&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="创建视图，重新格式化查询数据">创建视图，重新格式化查询数据</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW vendorlocation AS&#10;SELECT Concat(RTrim(vend_name),&#39; (&#39;, RTrim(vend_country),&#39;)&#39;)&#10;    AS vend_title&#10;FROM vendors&#10;ORDER BY vevnd_name;&#10;&#10;SELECT *&#10;FROM vendorlocations;</span><br></pre></td></tr></table></figure>
<h4 id="视图查询，过滤数据">视图查询，过滤数据</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#35270;&#22270;&#25226;cust_email = NULL &#30340;&#34892;&#36807;&#28388;&#25481;&#20102;&#10;//&#26597;&#35810;&#30340;&#26102;&#20505;&#23601;&#21487;&#20197;&#30465;&#21435;&#36807;&#28388;&#30340;&#27493;&#39588;&#10;CREATE VIEW customeremaillist AS&#10;SELECT cust_id, cust_name, cust_email&#10;FROM customers&#10;WHERE cust_email IS NOT NULL;&#10;&#10;SELECT *&#10;FROM customeremaillist;&#10;&#10;//&#22914;&#26524;&#22312;&#26597;&#35810;&#35270;&#22270;&#30340;&#26102;&#20505;&#65292;&#20197;&#21450;&#35270;&#22270;&#23454;&#29616;&#30340;&#26102;&#20505;&#37117;&#29992;&#21040;&#20102;WHERE&#20851;&#38190;&#23383;&#10;//&#37027;&#20040;&#65292;&#36825;&#20004;&#20010;WHERE &#23558;&#20250;&#34987;&#21512;&#24182;</span><br></pre></td></tr></table></figure>
<h4 id="更新视图(INSERT,UPDATE,DELETE)">更新视图(INSERT,UPDATE,DELETE)</h4><p>原则：<strong>视图的主要目的是为了简化和方便检索</strong>，并不是所有所图都是可更新的。<br>简单来说，如果MySQL不能正确的确定被更新的基数据，则不允许更新。<br>如果视图有以下操作，则不能进行更新：</p>
<ul>
<li>GROUP BY 和 HAVING</li>
<li>联结 JOIN </li>
<li>子查询</li>
<li>合并 UNION</li>
<li>聚合函数 MIN(),MAX(),AVG(),SUM(),COUNT()</li>
<li>DISTINCT</li>
<li>包含计算</li>
</ul>
<h2 id="存储过程">存储过程</h2><h4 id="简介">简介</h4><p>存储过程可以认为是多条MySQL语句的集合，但是其又不仅仅只是MySQL语句的简单堆切，更形象一点的或许可以理解<br>为是MySQL中的批处理程序</p>
<h4 id="为什么要使用存储过程">为什么要使用存储过程</h4><ul>
<li>简化应用层逻辑</li>
<li>安全,限制对基础数据的访问以减少数据出错</li>
<li>提高性能,存储过程比单独的SQL语句要快</li>
</ul>
<h4 id="修改终止符">修改终止符</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //&#10;...&#10;//&#10;DELIMITER;&#10;&#10;&#38500;\ &#31526;&#21495;&#22806;&#65292;&#20219;&#20309;&#23383;&#31526;&#37117;&#21487;&#20197;&#29992;&#20570;&#35821;&#21477;&#20998;&#38548;&#31526;</span><br></pre></td></tr></table></figure>
<h4 id="查看存储过程创建">查看存储过程创建</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE ordertotal;</span><br></pre></td></tr></table></figure>
<h4 id="变量传递">变量传递</h4><ul>
<li>调用时,变量传递皆以 @ 开头</li>
<li>声明时,变量分为 IN 和 OUT 两种类型，分别表示传入和传出<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE ordertotal(&#10;    IN onumber INT,&#10;    IN taxable BOOLEAN,&#10;    OUT ototal DECIMAL(8,2)&#10;)COMMENT &#39;Obtain order total,optionally add tax&#39;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="变量赋值">变量赋值</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Avg(prod_price) INTO pa FROM products;</span><br></pre></td></tr></table></figure>
<h4 id="变量声明">变量声明</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE total DECIMAL(8,2);</span><br></pre></td></tr></table></figure>
<h4 id="注释">注释</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--</span><br></pre></td></tr></table></figure>
<h4 id="调用存储过程">调用存储过程</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL ordertotal(20009,@total);</span><br></pre></td></tr></table></figure>
<h4 id="一个完整的存储过程实例">一个完整的存储过程实例</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- Name: ordertotal&#10;-- Parameters: onumber = order number&#10;--             taxable = 0 if not taxable ,1 if taxable&#10;--             ototal = order total variable&#10;CREATE PROCEDURE ordertotal(&#10;    IN onumber INT,&#10;    IN taxable BOOLEAN,&#10;    OUT ototal DECIMAL(8,2)&#10;)COMMENT &#39;Obtain order total,optionally add tax&#39;&#10;BEGIN&#10;    --Declare variable fot total&#10;    DECLARE total DECIMAL(8,2);&#10;&#10;    --Declare tax percentage&#10;    DECLARE taxrate INT DEFAULT 6;&#10;&#10;    --GET the order total&#10;    SELECT SUM(item_price * quantity)&#10;    FROM orderitems&#10;    WHERE order_num = onumber&#10;    INTO total;&#10;&#10;    --Is this taxable &#10;    IF taxable THEN&#10;        --Yes,so add taxrate to the total&#10;        SELELCT total + (total/100*taxrate) INTO total;&#10;    END IF;&#10;&#10;    --Finally,save to out variable&#10;    SELECT total INTo ototal;&#10;END;&#10;&#10;//&#35843;&#29992;&#10;CALL ordertotal(20005,0,@total);&#10;&#10;//&#33719;&#21462;&#35745;&#31639;&#32467;&#26524;total&#10;SELECT @total;</span><br></pre></td></tr></table></figure>
<h2 id="游标">游标</h2><h4 id="概述-1">概述</h4><p>游标（cursor）是一个存储在MySQL中的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果即。通过游标，我们可以对结果即进行跟进一步的处理。<br>MySQL的游标只能被用于存储过程和函数</p>
<h4 id="声明游标">声明游标</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()&#10;BEGIN&#10;    DECLARE ordernumbers CURSOR&#10;    FOR &#10;    SELECT order_num FROm orders;&#10;END;</span><br></pre></td></tr></table></figure>
<h4 id="打开游标">打开游标</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN ordernumbers;</span><br></pre></td></tr></table></figure>
<h4 id="关闭游标">关闭游标</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE ordernumbers;</span><br></pre></td></tr></table></figure>
<h4 id="REPEAT_…_FETCH_…_UNTIL_()_END_REPEAT">REPEAT … FETCH … UNTIL () END REPEAT</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN ordernumbers;&#10;REPEAT&#10;    FETCH ordernumbers INTO o&#10;UNTIL done END REPEAT;&#10;CLOSE ordernumbers;</span><br></pre></td></tr></table></figure>
<h4 id="DECLARE_CONTINUE_HANDLER_FOR_…">DECLARE CONTINUE HANDLER FOR …</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#35774;&#32622;&#26465;&#20214;&#10;//&#24403;SQLSTATE &#8216;02000&#8217; &#20986;&#29616;&#26102;&#65292;&#35774;&#32622;done = 1&#10;DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;0200&#39; SET done = 1;</span><br></pre></td></tr></table></figure>
<h4 id="一个完整的游标例子">一个完整的游标例子</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()&#10;BEGIN&#10;    DECLARE done BOOLEAN DEFAULT 0;&#10;    DECLARE o INT;&#10;    DECLARE t DECIMAL(8,2);&#10;&#10;    DECLARE ordernumbers CURSOR&#10;    FOR&#10;    SELECT order_num FROM orders;&#10;    DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;02000&#39; SET done = 1;&#10;&#10;    CREATE TABLE IF NOT EXISTS ordertotals&#10;        (order_num INT, total DECIMAL(8,2));&#10;&#10;    OPEN ordernumbers;&#10;&#10;    REPEAT&#10;        FETCH ordernumbers INTO o;&#10;        CALL ordertoal(o,1,t);&#10;&#10;        INSERT INTO ordertotals(order_num,total)&#10;        VALUES(o,t);&#10;    UNTIL doen END REPEAT;&#10;    &#10;    CLOSE ordernumbers;&#10;END;</span><br></pre></td></tr></table></figure>
<h2 id="触发器">触发器</h2><h4 id="简介-1">简介</h4><p>通过创建触发器，设置在DELETE/UPDATE/INSERT的BEFORE/AFTER时触发一个事件。</p>
<h4 id="可以使用触发器的语句">可以使用触发器的语句</h4><ul>
<li>DELETE</li>
<li>INSERT</li>
<li>UPDATE</li>
</ul>
<h4 id="创建触发器">创建触发器</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE account(acct_num INT,amount DECIMAL(10,2));&#10;&#10;CREATE TRIGGER ins_sum BEFORE INSER ON account&#10;FOR EACH ROW SET @sum = @sum + NEW.amount;&#10;&#10;SET @sum = 0;&#10;INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00);&#10;SELECT @sum AS &#39;Total amount inserted&#39;;&#10;+-----------------------+&#10;| Total amount inserted |&#10;+-----------------------+&#10;| 1852.48               |&#10;+-----------------------+&#10;//&#22312;&#21521;products&#25554;&#20837;&#19968;&#26465;&#25968;&#25454;&#20197;&#21518;&#20250;&#26174;&#31034;&#8216;&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="删除一个触发器">删除一个触发器</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER test.ins_sum;</span><br></pre></td></tr></table></figure>
<h4 id="Example">Example</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delimiter //&#10;CREATE TRIGGER upd_check BEFORE UPDATE ON account&#10;FOR EACH ROW&#10;BEGIN&#10;   IF NEW.amount &#60; 0 THEN&#10;      SET NEW.amount = 0;&#10;   ELSEIF NEW.amount &#62; 100 THEN&#10;      SET NEW.amount = 100;&#10;   END IF;&#10;END;//&#10;delimiter ;</span><br></pre></td></tr></table></figure>
<h4 id="注意点：">注意点：</h4><ul>
<li>不能在同一个表上添加多个同类型的触发器（如：不能针对同一个表添加两个BEFORE UPDATE 触发器）</li>
<li>每个数据库中，触发器的名字必须是唯一的</li>
</ul>
<h2 id="用户权限管理">用户权限管理</h2><h4 id="查看用户">查看用户</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;&#10;SELECT user FROM user;</span><br></pre></td></tr></table></figure>
<h4 id="创建用户">创建用户</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER zz IDENTIFIED BY &#39;p@ssw0rd&#39;;&#10;&#10;//IDENTIFIED BY &#35774;&#32622;&#23494;&#30721;&#65292;&#26368;&#32456;&#20445;&#25345;&#30340;&#23494;&#30721;&#26159;&#32463;&#36807;&#21152;&#23494;&#30340;</span><br></pre></td></tr></table></figure>
<h4 id="重命名用于">重命名用于</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME USER zz TO zoth;&#10;//&#38656;&#35201;&#26377;CREATE &#26435;&#38480;</span><br></pre></td></tr></table></figure>
<h4 id="删除账号">删除账号</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER zoth;</span><br></pre></td></tr></table></figure>
<h4 id="查看访问权限">查看访问权限</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR zoth;</span><br></pre></td></tr></table></figure>
<h4 id="设置访问权限_GRANT_…_REVOKE_…">设置访问权限 GRANT … REVOKE …</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT ON crashcourse.* TO zoth;&#10;//&#36171;&#20104;zoth&#23545;crashcourse&#25968;&#25454;&#24211;&#20013;&#25152;&#26377;&#34920;&#30340;&#35835;&#65288;select&#65289;&#26435;&#38480;</span><br></pre></td></tr></table></figure>
<h4 id="取消权限">取消权限</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE SELECT ON crashcourse.* TO zoth;</span><br></pre></td></tr></table></figure>
<h4 id="权限控制层次">权限控制层次</h4><ul>
<li>整个服务器 GRANT ALL/ REVOKE ALL</li>
<li>整个数据库 ON database.*</li>
<li>特定的表 ON database.table</li>
<li>特定的列</li>
<li>特定的存储过程</li>
</ul>
<h4 id="权限列表">权限列表</h4><table>
<thead>
<tr>
<th style="text-align:center">权限</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ALL</td>
<td style="text-align:left">除GRANT OPTION 外的所有权限</td>
</tr>
<tr>
<td style="text-align:center">ALTER</td>
<td style="text-align:left">ALTER TABLE</td>
</tr>
<tr>
<td style="text-align:center">ALTER ROUTINE</td>
<td style="text-align:left">ALTER PROCEDURE / DROP PROCEDURE</td>
</tr>
<tr>
<td style="text-align:center">CREATE</td>
<td style="text-align:left">CREATE TABLE</td>
</tr>
<tr>
<td style="text-align:center">CREATE ROUTINE</td>
<td style="text-align:left">CREATE PROCEDURE</td>
</tr>
<tr>
<td style="text-align:center">CREATE TEMPORARY TABLES</td>
<td style="text-align:left">CREATE TEMPORARY TABLE</td>
</tr>
<tr>
<td style="text-align:center">CREATE USER</td>
<td style="text-align:left">CREATE USER/ DROP USER / RENAME USER /REVOKE ALL PRIVILEGES</td>
</tr>
<tr>
<td style="text-align:center">CREATE VIEW</td>
<td style="text-align:left">CREATE VIEW</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:left">DELETE</td>
</tr>
<tr>
<td style="text-align:center">DROP</td>
<td style="text-align:left">DROP TABLE</td>
</tr>
<tr>
<td style="text-align:center">EXECURE</td>
<td style="text-align:left">CALL / 存储过程</td>
</tr>
<tr>
<td style="text-align:center">FILE</td>
<td style="text-align:left">SELECT INTO OUTFILE/ LOAD DATA INFILE</td>
</tr>
<tr>
<td style="text-align:center">GRANT OPTION</td>
<td style="text-align:left">GRANT / REVOKE</td>
</tr>
<tr>
<td style="text-align:center">INDEX</td>
<td style="text-align:left">CREATE INDEX / DROP INDEX</td>
</tr>
<tr>
<td style="text-align:center">INSERT</td>
<td style="text-align:left">INSERT</td>
</tr>
<tr>
<td style="text-align:center">LOCK TABLES</td>
<td style="text-align:left">LOCK TABLES</td>
</tr>
<tr>
<td style="text-align:center">PROCESS</td>
<td style="text-align:left">SHOW FULL PROCESSLIST</td>
</tr>
<tr>
<td style="text-align:center">RELOAD</td>
<td style="text-align:left">FLUSH</td>
</tr>
<tr>
<td style="text-align:center">PRELICATION CLIENT</td>
<td style="text-align:left">服务器位置访问</td>
</tr>
<tr>
<td style="text-align:center">REPLICATION SLAVE</td>
<td style="text-align:left">???</td>
</tr>
<tr>
<td style="text-align:center">SELECT</td>
<td style="text-align:left">SELECT</td>
</tr>
<tr>
<td style="text-align:center">SHOW DATABASES</td>
<td style="text-align:left">SHOW DATABASES</td>
</tr>
<tr>
<td style="text-align:center">SHOW VIEW</td>
<td style="text-align:left">SHOW VIEW</td>
</tr>
<tr>
<td style="text-align:center">SHUTDOWN</td>
<td style="text-align:left">mysqladmin shutdown</td>
</tr>
<tr>
<td style="text-align:center">SUPER</td>
<td style="text-align:left">CHANGE MASTER, KILL ,LOGS, PURGE, MASTER, SET GLOBAL</td>
</tr>
<tr>
<td style="text-align:center">UPDATE</td>
<td style="text-align:left">UPDATE</td>
</tr>
<tr>
<td style="text-align:center">USAGE</td>
<td style="text-align:left">无访问权限</td>
</tr>
</tbody>
</table>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/3354490" target="_blank" rel="external">MySQL 必知必会</a></li>
<li><a href="http://dev.mysql.com/doc/refman/5.5/en/trigger-syntax.html" target="_blank" rel="external">MySQL Trigger Syntax and Examples</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2><p>本文接上文<a href="/blog/2015/01/14/mysql-crash-course-1/">MySQL 知识点整理(上)</a>,<a href="/blog/2015/01/14/mysql-crash-course-]]>
    </summary>
    
      <category term="MySQL" scheme="http://fengcode.com/tags/MySQL/"/>
    
      <category term="MySQL" scheme="http://fengcode.com/categories/MySQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL 知识点整理二]]></title>
    <link href="http://fengcode.com/2015/01/26/mysql-crash-course-2/"/>
    <id>http://fengcode.com/2015/01/26/mysql-crash-course-2/</id>
    <published>2015-01-26T03:21:56.000Z</published>
    <updated>2015-06-24T10:21:39.150Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>本文接上文<a href="http://www.fengcode.com/blog/2015/01/14/mysql-crash-course-1/" target="_blank" rel="external">MySQL 知识点整理(上)</a><br>本部分主要梳理了MySQL的分组查询、子查询、联结表、组合查询、全文搜索、以及插入/更新/删除数据等。</p>
<h2 id="GROUP_BY_分组数据">GROUP BY 分组数据</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods&#10;FROM products&#10;GROUP BY vend_id;</span><br></pre></td></tr></table></figure>
<ul>
<li>对分组结果进行过滤</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id, COUNT(*) AS orders&#10;FROM orders&#10;GROUP BY cust_id&#10;HAVING COUNT(*) &#62;= 2;</span><br></pre></td></tr></table></figure>
<ul>
<li>HAVING 和 WHERE 的区别：<br>WHERE在数据分组之前进行过滤，HAVING在数据分组后进行过滤。<br>如果WHERE和HAVING同时使用，则需要注意，WHERE排除的行不包括在分组内。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods&#10;FROM products&#10;WHERE prod_price &#62;= 10&#10;GROUP BY vend_id&#10;HAVING COUNT(*) &#62;= 2;</span><br></pre></td></tr></table></figure>
<ul>
<li>分组和排序<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#19968;&#33324;GROUP BY&#20197;&#21518; &#65292;&#29992;ORDER BY &#30830;&#20445;&#25968;&#25454;&#26159;&#27491;&#30830;&#25490;&#24207;&#30340;&#10;SELECT order_num, SUM(quantity * item_price) AS ordertotal&#10;FROM orderitems&#10;GROUP BY order_num&#10;HAVING SUM(quantity * item_price) &#62;= 50&#10;ORDER BY ordertotal;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="子查询">子查询</h2><ul>
<li><p>一级子查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id&#10;FROM order&#10;WHERE order_num IN(&#10;    SELECT order_num &#10;    FROM orderitems&#10;    WHERE prod_id = &#39;TNT2&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>多级子查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact&#10;FROM customers&#10;WHERE cust_id IN (SELECT cust_id&#10;                    FROM orders&#10;                    WHERE order_num IN(SELECT order_num&#10;                                        FROM orderitems&#10;                                        WHERE prod_id = &#39;TNT2&#39;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>子查询作为结果的一部分</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name,&#10;       cust_state,&#10;       (SELECT COUNT(*)&#10;        FROM orders&#10;        WHERE orders.cust_id = customers.cust_id) AS orders&#10;FROM customers&#10;ORDER BY cust_name;&#10;&#10;//&#27880;&#24847;orders.cust_id = customers.cust_id &#22312;&#24341;&#29992;&#30340;&#21015;&#21487;&#33021;&#20986;&#29616;&#20108;&#20041;&#24615;&#26159;&#65292;&#10;&#24517;&#39035;&#29992;&#23436;&#20840;&#38480;&#23450;&#21015;&#21517;,&#29992;&#19968;&#20010;&#28857;&#20998;&#38548;&#30340;&#34920;&#21517;&#21644;&#21015;&#21517;&#12290;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="联结表">联结表</h2><ul>
<li><p>普通联结</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price&#10;FROM vendors, products&#10;WHERE vendors.vend_id = products.vend_id&#10;ORDER BY vend_name, prod_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>笛卡尔积(第一个表的行*第二个表的行) 没有指明条件的情况下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price&#10;FROM vendors, products&#10;ORDER BY vend_name, prod_name;&#10;&#10;//&#19981;&#35201;&#24536;&#20102;WHERE</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="内部联结">内部联结</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#26126;&#30830;&#23450;&#20041;&#32852;&#32467;&#31867;&#22411;&#8212;&#8212;&#20869;&#37096;&#32852;&#32467;&#10;SELECT vend_name, prod_name, prod_price&#10;FROM vendors INNER JOIN products&#10;ON vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<h4 id="联结多个表">联结多个表</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, vend_name, prod_price, quantity&#10;FROM orderitems, products, vendors&#10;WHERE products.vend_id = vendors.vend_id&#10;    AND orderitems.prod_id = products.prod_id&#10;    AND order_num = 20005;</span><br></pre></td></tr></table></figure>
<h4 id="使用表别名">使用表别名</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact&#10;FROM customers AS c, orders AS o, orderitems AS oi&#10;WHERE c.cust_id = o.cust_id&#10;    AND oi.order_num = o.order_num&#10;    AND prod_id = &#39;TNT2&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="自联结">自联结</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_name&#10;FROM products&#10;WHERE vend_id = (SELECT vend_id&#10;                 FROM products&#10;                 WHERE prod_id = &#39;DTNTR&#39;);&#10;&#31561;&#20215;&#20110;&#10;&#10;SELECT p1.prod_id, p1.prod_name&#10;FROM products AS p1, products AS p2&#10;WHERE p1.vend_id = p2.vend_id&#10;    AND p2.prod_id = &#39;DTNTR&#39;&#65307;</span><br></pre></td></tr></table></figure>
<h4 id="自然联结">自然联结</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#33258;&#28982;&#32852;&#32467;&#25490;&#38500;&#21015;&#20986;&#29616;&#22810;&#27425;&#30340;&#21487;&#33021;&#65292;&#20351;&#32467;&#26524;&#20013;&#27599;&#20010;&#21015;&#21482;&#36820;&#22238;&#19968;&#27425;&#10;&#10;SELECT c.*, o.order_num, o.order_date,&#10;        oi.prod_id, oi.quantity,oi.item_price&#10;FROM customers AS c, orders AS o, orderitems AS oi&#10;WHERE c.cust_id = o.cust_id&#10;    AND oi.order_num = o.order_num&#10;    AND oi.prod_id = &#39;FB&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="外部联结">外部联结</h4><ul>
<li><p>LEFT OUTER JOIN … ON</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_id, orders.order_num &#10;FROM customers LEFT OUTER JOIN orders&#10;ON customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RIGHT OUTER JOIN … ON</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_id, orders.order_num&#10;FROM customers RIGHT OUTER JOIN orders&#10;ON orders.cust_id = customers.cust_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>INNER JOIN … GROUP BY</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_name,&#10;        customers.cust_id,&#10;        COUNT(orders.order_num) AS num_ord&#10;FROM customers INNER JOIN orders&#10;ON customers.cust_id = orders.cust_id&#10;GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LELFT OUTER JOIN … ON … GROUP BY</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_name,&#10;        customers.cust_id,&#10;        COUNT(orders.order_num) AS num_ord&#10;FROM customers LEFT OUTER JOIN orders&#10;ON customers.cust_id = orders.cust_id&#10;GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="UNION_组合查询">UNION 组合查询</h2><p>UNION 规则：</p>
<ul>
<li>UNION 必须由两条或两条以上的SELECT语句组成，语句之间用UNION分隔</li>
<li>UNION 中的每个查询必须包含相同的列，表达式或聚合函数（列的顺序不一定要相同）</li>
<li>列数据类型必须兼容:类型不必完全相同，但补习是DBMS可以隐含地转换的类型（有可能两种表中相同的列采用了不同的数据类型）</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//UNION ALL &#21487;&#33021;&#21253;&#21547;&#37325;&#22797;&#30340;&#34892;&#65288;&#21363;&#28385;&#36275;prod_price &#60;=5 &#21448;&#28385;&#36275; vend_id IN (1001,1002&#65289;&#30340;&#34892;&#20986;&#29616;&#20004;&#27425;&#10;//UNION &#33258;&#21160;&#21435;&#38500;&#37325;&#22797;&#30340;&#34892;&#65288;&#20854;&#34892;&#20026;&#19982;&#21333;&#20010;SELECT&#35821;&#21477;&#65292;&#22810;&#20010;WHERE&#26465;&#20214;&#30456;&#21516; WHERE prod_price &#60;=5 OR vend_id IN (1001,1002);)&#10;SELECT vend_id, prod_id, prod_price&#10;FROM products&#10;WHERE prod_price &#60;= 5&#10;UNION ALL &#10;SELECT vend_id, prod_id, prod_price&#10;FROM products&#10;WHERE vend_id IN (1001,1002);</span><br></pre></td></tr></table></figure>
<h2 id="全文本搜索">全文本搜索</h2><ul>
<li>MyISAM 引擎支持全文本搜索</li>
<li><p>InnoDB 引擎不支持全文搜索</p>
</li>
<li><p>匹配note_text 列中包含anvils 关键字的行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text&#10;FROM productnotes&#10;WHERE Match(note_text) Against(&#39;anvils&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用查询扩展 （会匹配出一些不包含anvils但是相关联的行）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text&#10;FROM productnotes&#10;WHERE Match(note_text) Against (&#39;anvils&#39; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure>
</li>
<li><p>BOOL 模式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text&#10;FROM productnotes&#10;WHERE Match(note_text) Against (&#39;heavy -rope*&#39; IN BOOLEAN MODE);&#10;&#25490;&#38500;&#20219;&#20309;&#21253;&#21547;rope&#24320;&#22987;&#30340;&#35789;&#30340;&#34892;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>全文本布尔操作符</p>
<table>
<thead>
<tr>
<th>布尔操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>包含，词必须存在</td>
</tr>
<tr>
<td>-</td>
<td>排除，词必须不出现</td>
</tr>
<tr>
<td>&gt;</td>
<td>包含，而且增加等级值</td>
</tr>
<tr>
<td>&lt;</td>
<td>包含，而且减小等级值</td>
</tr>
<tr>
<td>()</td>
<td>把词组成子表达式（允许这些子表达式作为组被包含、排除、排列等)</td>
</tr>
<tr>
<td>~</td>
<td>取消一个词的排序值</td>
</tr>
<tr>
<td>*</td>
<td>词尾的通配符</td>
</tr>
<tr>
<td>“”</td>
<td>定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语)</td>
</tr>
</tbody>
</table>
<ul>
<li><p>搜索匹配包含词rabbit和bait的行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text&#10;FROM productnotes&#10;WHERE Match(note_text) Against(&#39;+rabbit +bait&#39; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>搜索匹配包含rabbit和bait中的至少一个的行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text&#10;FROM productnotes&#10;WHERE Match(note_text) Against(&#39;rabbit bait&#39; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>搜索匹配短语rabbit bait 而不是匹配两个词 rabbit 和 bait</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text&#10;FROM productnotes&#10;WHERE Match(note_text) Against(&#39;&#34;rabbit bait&#34;&#39; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>搜索匹配包含rabbit和carrot至少一个的词，增加前者的等级，降低后者的等级</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text&#10;FROM productnotes&#10;WHERE Match(note_text) Against (&#39;&#62;rabbit &#60;carrot&#39; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>搜索匹配词safe和combination，降低后者的等级</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text&#10;FROM productnotes&#10;WHERE Match(note_text) Against(&#39;+safe +(&#60;combination)&#39; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/3354490/" target="_blank" rel="external">MySQL 必知必会</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2><p>本文接上文<a href="http://www.fengcode.com/blog/2015/01/14/mysql-crash-course-1/" target="_blank" rel="external">MySQL 知识点整]]>
    </summary>
    
      <category term="MySQL" scheme="http://fengcode.com/tags/MySQL/"/>
    
      <category term="MySQL" scheme="http://fengcode.com/categories/MySQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL 知识点整理一]]></title>
    <link href="http://fengcode.com/2015/01/24/mysql-crash-course-1/"/>
    <id>http://fengcode.com/2015/01/24/mysql-crash-course-1/</id>
    <published>2015-01-24T03:21:48.000Z</published>
    <updated>2015-06-24T10:21:54.878Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>本文梳理了MySQL的常用语法和操作，持续不断完善中…</p>
<h1 id="基本操作">基本操作</h1><h2 id="查看数据库详情">查看数据库详情</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>
<h2 id="选择数据库">选择数据库</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE DATABASE;</span><br></pre></td></tr></table></figure>
<h2 id="查看选定数据库中的表">查看选定数据库中的表</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>
<h2 id="显示表中的列">显示表中的列</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW COLUMNS FROM tablename;</span><br></pre></td></tr></table></figure>
<p>此外其它关于SHOW的用法<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* SHOW STATUS  &#26174;&#31034;&#26381;&#21153;&#22120;&#29366;&#24577;&#20449;&#24687;&#10;* SHOW CREATE DATABASE  &#26174;&#31034;&#25968;&#25454;&#24211;&#21019;&#24314;&#35821;&#21477;&#10;* SHOW CREATE TABLE &#26174;&#31034;&#34920;&#21019;&#24314;&#35821;&#21477;&#10;* SHOW GRANTS &#26174;&#31034;&#25480;&#20104;&#29992;&#25143;&#30340;&#23433;&#20840;&#26435;&#38480;&#10;* SHOW ERRORS &#26174;&#31034;&#26381;&#21153;&#22120;&#38169;&#35823;&#20449;&#24687;&#10;* SHOW WARNINGS &#26174;&#31034;&#26381;&#21153;&#22120;&#35686;&#21578;&#20449;&#24687;</span><br></pre></td></tr></table></figure></p>
<h2 id="创建表">创建表</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE customers &#10;(&#10;    cust_id int NOT NULL AUTO_INCREMENT,&#10;    cust_name char(50) NOT NULL,&#10;    cust_address char(50) NOT NULL,&#10;    cust_city char(50) NULL,&#10;    cust_state char(5) NULL,&#10;    cust_zip char(10) NULL,&#10;    cust_country char(50) NULL,&#10;    cust_contact char(50) NULL,&#10;    cust_email char(255) NULL,&#10;    PRIMARY KEY (cust_id)&#10;)ENGINE = InnoDB;&#10;&#10;1. &#35774;&#32622;&#20026; NOT NULL &#23558;&#20250;&#38459;&#27490;&#35797;&#22270;&#25554;&#20837;&#27809;&#26377;&#20540;&#30340;&#21015;&#10;2. PRIMARY KEY(order_num, order_item) &#21019;&#24314;&#30001;&#22810;&#20010;&#21015;&#32452;&#25104;&#30340;&#20027;&#38190;&#10;  &#65288;&#36825;&#31181;&#24773;&#20917;&#19979;&#65292;order_num &#21644; order_item &#30340;&#32452;&#21512;&#26159;&#21807;&#19968;&#30340;,&#21487;&#20197;&#21807;&#19968;&#30830;&#23450;&#19968;&#26465;&#35760;&#24405;&#65289;&#10;3. &#27599;&#20010;&#34920;&#21482;&#20801;&#35768;&#19968;&#20010;AUTO_INCREMENT &#21015;&#65292;&#27599;&#22686;&#21152;&#19968;&#21015;&#30340;&#26102;&#20505;&#65292;&#35813;&#21015;&#30340;&#20540;&#33258;&#21160;&#22686;&#21152;1</span><br></pre></td></tr></table></figure>
<h2 id="几个常见的引擎">几个常见的引擎</h2><ul>
<li>InnoDB 是一个可靠的事务处理引擎，它不支持全文本搜索</li>
<li>MEMORY 在功能上等同于MyISAM，但由于数据存储在内存中，速度很快，特别适合临时表</li>
<li>MyISAM 是一个性能极高的引擎，它支持全文本搜索，但不支持实务处理</li>
</ul>
<h2 id="ALTER_修改表">ALTER 修改表</h2><ul>
<li><p>添加字段</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE vendors&#10;ADD vend_phone CHAR(20);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义外键</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE orderitems&#10;ADD CONSTRAINT fk_orderitems_orders&#10;FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对单张表实现多次修改<br>对单张表实现多次修改的时候，可以使用单条ALTER TABLE 语句，每个更改用逗号分隔</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user&#10;ADD name varchar(20), &#10;ADD address varchar(255);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="DROP_TABLE_删除表">DROP TABLE 删除表</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE customers2;</span><br></pre></td></tr></table></figure>
<h2 id="RENAME_TABLE_重命名表">RENAME TABLE 重命名表</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE customers2 TO customers;&#10;&#10;//&#19968;&#27425;&#24615;&#37325;&#21629;&#21517;&#22810;&#24352;&#34920;&#10;RENAME TABLE backup_customers TO customers,&#10;            backup_vendors TO vendors,&#10;            backup_products TO products;</span><br></pre></td></tr></table></figure>
<h2 id="SELECT_检索数据">SELECT 检索数据</h2><h4 id="检索单列">检索单列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_name </span><br><span class="line"><span class="keyword">FROM</span> products;</span></span><br></pre></td></tr></table></figure>
<h4 id="检索多列">检索多列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price </span><br><span class="line"><span class="keyword">FROM</span> products;</span></span><br></pre></td></tr></table></figure>
<h4 id="检索所有行">检索所有行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> products;</span>  在并不需要获取全部列的时候，慎用通配符, 因为检索不需要的列通常会降低应用程序性能.</span><br></pre></td></tr></table></figure>
<h4 id="检索不同的行">检索不同的行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id </span><br><span class="line"><span class="keyword">FROM</span> products;</span></span><br></pre></td></tr></table></figure>
<h4 id="限制查询条数">限制查询条数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name </span><br><span class="line">FROM products LIMIT 5,10; </span><br><span class="line"></span><br><span class="line">从第五行后开始，检索10条结果(第6-第15条结果) 等价于</span><br><span class="line"></span><br><span class="line">SELECT prod_name </span><br><span class="line">FROM products LIMIT 10 OFFSET 5;</span><br><span class="line"></span><br><span class="line">(MySQL &gt; 5)</span><br></pre></td></tr></table></figure>
<h4 id="使用完全限定的表名">使用完全限定的表名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> tablename.prod_name </span><br><span class="line"><span class="keyword">FROM</span> databasename.products;</span></span><br></pre></td></tr></table></figure>
<h2 id="ORDER_BY_排序">ORDER BY 排序</h2><h4 id="排序数据">排序数据</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name &#10;FROM products &#10;ORDER BY prod_name;&#10;&#10;(&#24182;&#38750;&#24517;&#39035;&#35201;&#29992;&#24403;&#21069;&#26816;&#32034;&#30340;&#21015;&#36827;&#34892;&#25490;&#24207;,&#29992;&#38750;&#26816;&#32034;&#30340;&#21015;&#25490;&#24207;&#20063;&#26159;&#23436;&#20840;&#21512;&#27861;&#30340;&#65289;</span><br></pre></td></tr></table></figure>
<h4 id="按多多个咧排序">按多多个咧排序</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name &#10;FROM products &#10;ORDER BY prod_price, prod_name;</span><br></pre></td></tr></table></figure>
<h4 id="指定排序方向">指定排序方向</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name &#10;FROM products &#10;ORDER BY prod_price DESC, prod_name;&#10;&#65288;&#40664;&#35748;&#26159;ASC&#30340;&#65292;&#22914;&#26524;&#35201;&#23545;&#27599;&#20010;&#21015;&#37117;&#36827;&#34892;&#38477;&#24207;&#25490;&#24207;&#65292;&#38656;&#35201;&#23545;&#27599;&#21015;&#37117;&#21046;&#23450;DESC&#65289;</span><br></pre></td></tr></table></figure>
<h4 id="ORDER_BY_和_LIMIT_结合">ORDER BY 和 LIMIT 结合</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_price FROM products ORDER BY prod_price DESC LIMIT 5,10;</span><br></pre></td></tr></table></figure>
<h2 id="WHERE_过滤">WHERE 过滤</h2><p>备注：数据过滤的工作可以在数据库查询的时候过滤，也可以在应用程序中进行过滤（查询出所有的行返回给应用程序），但是后者会极大的影响应用程序的性能，并且创建的应用不具备可伸缩性,同时如果应用程序和数据库通过网络连接交互的话，必然会增大网络传输的压力,造成网络带宽的浪费。</p>
<h4 id="WHERE_字句操作符">WHERE 字句操作符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>说明        </th>
</tr>
</thead>
<tbody>
<tr>
<td> =</td>
<td>等于       </td>
</tr>
<tr>
<td> &lt;&gt;</td>
<td>不等于      </td>
</tr>
<tr>
<td> !=</td>
<td>不等于      </td>
</tr>
<tr>
<td> &lt;</td>
<td>小于       </td>
</tr>
<tr>
<td> &lt;=</td>
<td>小于等于    </td>
</tr>
<tr>
<td> ></td>
<td>大于       </td>
</tr>
<tr>
<td> >=</td>
<td>大于等于  </td>
</tr>
<tr>
<td> BETWEEN</td>
<td>在指定的两个值之间</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="检查单个值">检查单个值</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price &#10;FROM products &#10;WHERE prod_name = &#39;foses&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="不匹配检查">不匹配检查</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, prod_name &#10;FROM products &#10;WHERE vend_id &#60;&#62; 1003;</span><br></pre></td></tr></table></figure>
<h4 id="范围检查">范围检查</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price &#10;FROM products &#10;WHERE prod_price BETWEEN 5 AND 10;</span><br></pre></td></tr></table></figure>
<h4 id="空值检查">空值检查</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Prod_name &#10;FROM products &#10;WHERE prod_price IS NULL;   &#10;&#10;(IS NOT NULL)</span><br></pre></td></tr></table></figure>
<h2 id="AND_操作符">AND 操作符</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name &#10;FROM products &#10;WHERE vend_id = 1003 AND prod_price &#60;= 10;</span><br></pre></td></tr></table></figure>
<h2 id="OR_操作符">OR 操作符</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price &#10;FROM products &#10;WHERE vend_id = 1002 OR vend_id = 1003;</span><br></pre></td></tr></table></figure>
<h2 id="AND_和OR_的优先级">AND 和OR 的优先级</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price&#10;FROM products&#10;WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &#62;= 10;&#10;&#10;&#20808;&#25191;&#34892;AND &#28982;&#21518; &#25191;&#34892;OR&#65292;&#22240;&#27492;&#36866;&#24403;&#30340;&#28155;&#21152;&#25324;&#21495;&#26159;&#26126;&#26234;&#30340;&#36873;&#25321;!</span><br></pre></td></tr></table></figure>
<h2 id="IN_操作符">IN 操作符</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price&#10;FROM products&#10;WHERE vend_id IN (1002,1003)&#10;ORDER BY prod_name;&#10;&#10;&#31561;&#20215;&#20110;&#10;&#10;SELECT prod_name, prod_price&#10;FROM products&#10;WHERE vend_id = 1002 OR vend_id = 1003&#10;ORDER BY prod_name;&#10;&#10;IN &#23376;&#21477;&#37324;&#36824;&#21487;&#21253;&#21547;&#21478;&#22806;&#19968;&#20010;SELECT&#26597;&#35810;&#65292;&#25226;&#20854;&#26597;&#35810;&#32467;&#26524;&#20316;&#20026;IN() &#30340;&#20869;&#23481;</span><br></pre></td></tr></table></figure>
<h2 id="WHERE_NOT_操作符">WHERE NOT 操作符</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price&#10;FROM products&#10;WHERE vend_id NOT IN (1002,1003)&#10;ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<h2 id="LIKE_通配符进行过滤">LIKE 通配符进行过滤</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_name&#10;FROM products&#10;WHERE prod_name LIKE &#39;jet%&#39; //jet &#24320;&#22987;&#30340;&#10;&#10;(WHERE prod_name LIKE &#39;%jet%&#39;)  //&#21253;&#21547;jet&#30340;&#10;(WHERE prod_name LIKE &#39;%jet&#39;) //jet&#32467;&#23614;&#30340;&#10;(WHERE prod_name LIKE &#39;s%e&#39;) &#10;(WHERE prod_name LIKE &#39;_ ton anvil&#39;) // 1 ton anvil&#10;&#10;&#24635;&#30340;&#26469;&#35828;&#65306; &#10;% &#20195;&#34920;&#20102;&#22312;&#25628;&#32034;&#27169;&#24335;&#20013;&#32473;&#23450;&#20301;&#32622;&#30340;0&#20010;&#65292;1&#20010;&#25110;&#22810;&#20010;&#20219;&#24847;&#21512;&#27861;&#23383;&#31526;&#10;_ &#20195;&#34920;&#20102;&#22312;&#25628;&#32034;&#27169;&#24335;&#20013;&#32473;&#23450;&#20301;&#32622;&#19968;&#20010;&#23383;&#31526;&#10;&#10;&#27880;&#24847;&#65306;&#10;1. (WHERE prod_name LIKE &#39;%&#39;;) &#19981;&#33021;&#21305;&#37197; prod_name &#20540;&#20026; NULL &#30340;&#34892;,&#20294;&#21487;&#20197;&#21305;&#37197;&#20854;&#23427;&#20219;&#20309;&#34892;&#12290;&#10;2. LIKE&#65292;&#29992;&#21518;&#36319;&#25628;&#32034;&#27169;&#24335;&#21033;&#29992;&#36890;&#37197;&#31526;&#21305;&#37197;&#65292;&#32780;&#19981;&#26159;&#30452;&#25509;&#21033;&#29992;&#30456;&#31561;&#21305;&#37197;&#36827;&#34892;&#27604;&#36739;,&#10;&#25442;&#35328;&#20043;&#65292;LIKE &#24212;&#35813;&#36319;&#36890;&#37197;&#31526;&#32467;&#21512;&#20351;&#29992;&#12290;</span><br></pre></td></tr></table></figure>
<h2 id="REGEXP_正则表达式进行搜索">REGEXP 正则表达式进行搜索</h2><h4 id="正则表达式基本字符匹配">正则表达式基本字符匹配</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name&#10;FROM products&#10;WHERE prod_name REGEXP &#39;1000&#39;&#10;ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式进行_OR_匹配">正则表达式进行 OR 匹配</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name&#10;FROM products&#10;WHERE prod_name REGEXP &#39;1000 | 2000&#8216;&#10;ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式匹配几个字符之一">正则表达式匹配几个字符之一</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name&#10;FROM products&#10;WHERE prod_name REGEXP &#39;[123] Ton&#39;&#10;ORDER BY prod_name;&#10;&#10;&#21306;&#21035;:&#10;(WHERE prod_name REGEXP &#39;1|2|3 Ton&#39;) &#21305;&#37197;1 &#25110; 2 &#25110; 3 ton ...</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式匹配范围">正则表达式匹配范围</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name&#10;FROM products&#10;WHERE prod_name REGEXP &#39;[1-5] Ton&#39;&#10;ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式匹配特殊字符">正则表达式匹配特殊字符</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name &#10;FROM vendors&#10;WHERE vend_name REGEXP &#39;\\.&#39;&#10;ORDER BY vend_name;&#10;&#10;&#21305;&#37197;&#25152;&#26377;vend_name &#21015;&#21253;&#21547;&#39;.&#39;&#23383;&#31526;&#30340;&#34892;&#10;&#10;&#29305;&#27530;&#23383;&#31526;&#38656;&#35201;&#36716;&#20041;&#65292;&#20004;&#20010;\\&#30340;&#35299;&#37322;&#65306;MySQL&#35299;&#26512;&#30340;&#26102;&#20505;&#19968;&#20010;&#65292;&#27491;&#21017;&#34920;&#36798;&#24335;&#24341;&#25806;&#35299;&#26512;&#30340;&#26102;&#20505;&#19968;&#20010;&#10;&#21516;&#29702;&#65292;&#22914;&#26524;&#35201;&#21305;&#37197;\&#65292;&#21017;&#38656;&#35201;&#20351;&#29992; REGEXP &#39;\\\&#39; &#20102;</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式匹配多个实例">正则表达式匹配多个实例</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>0个或多个</td>
</tr>
<tr>
<td>+</td>
<td>1个或多个 {1,}</td>
</tr>
<tr>
<td>?</td>
<td>0个或1个 {0,1}</td>
</tr>
<tr>
<td>{n}</td>
<td>指定数目的匹配</td>
</tr>
<tr>
<td>{n,}</td>
<td>不少于指定数目的匹配</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配指定范围 (m &lt;= 255)</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name &#10;FROM products&#10;WHERE prod_name REGEXP &#39;\\([0-9] sticks?\\)&#39;&#10;ORDER BY prod_name;&#10;&#10;prod_name&#10;TNT (1 stick)&#10;TNT (5 sticks)</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式定位符">正则表达式定位符</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>文本开始</td>
</tr>
<tr>
<td>$</td>
<td>文本结尾</td>
</tr>
<tr>
<td>[[:&lt;:]]</td>
<td>词的开始</td>
</tr>
<tr>
<td>[[:&gt;:]]</td>
<td>词的结尾</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name&#10;FROM products&#10;WHERE prod_name REGEXP &#8217;^[0-9\\.]&#39;&#10;ORDER BY prod_name;&#10;&#10;//&#21305;&#37197;&#20219;&#24847;&#19968;.&#25110;&#25968;&#23383;&#24320;&#22836;&#30340;&#10;&#27880;&#24847;&#65306;&#10;^ &#22312;&#38598;&#21512;&#20013;[],&#29992;&#26469;&#21542;&#23450;&#38598;&#21512; [^ ]; &#21542;&#21017;&#29992;&#26469;&#25351;&#20018;&#30340;&#24320;&#22987;&#22788;</span><br></pre></td></tr></table></figure>
<h4 id="Trick_在不适用数据库表的情况下，测试正则表达式">Trick 在不适用数据库表的情况下，测试正则表达式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &#39;hello&#39; REGEXP &#39;[0-9]&#39;;&#10;&#10;+-------------------------+&#10;| &#39;hello&#10;&#39; REGEXP &#39;[0-9]&#39; |&#10;+-------------------------+&#10;|                       0 |&#10;+-------------------------+&#10;1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="MySQL_处理函数">MySQL 处理函数</h2><h4 id="Concat_—_拼接字符串">Concat — 拼接字符串</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name), &#39;(&#39;, RTrim(vend_country),&#39;)&#39;)  AS vend_title&#10;FROM vendors&#10;ORDER BY vendor_name;&#10;&#10;RTrim()  &#21435;&#25481;&#21491;&#20391;&#31354;&#26684;&#10;LTRIM()  &#21435;&#25481;&#24038;&#20391;&#31354;&#26684;</span><br></pre></td></tr></table></figure>
<h4 id="算术计算">算术计算</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id,quantity,item_price,&#10;       quantity * item_price AS expanded_price&#10;FROM orderitems&#10;WHERE order_num = 20005;</span><br></pre></td></tr></table></figure>
<p>算术运算符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
</tr>
</tbody>
</table>
<ul>
<li>SELECT 测试运算<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&#62; SELECT  3 * 2;&#10;+-------+&#10;| 3 * 2 |&#10;+-------+&#10;|     6 |&#10;+-------+&#10;1 row in set (0.00 sec)&#10;&#10;mysql&#62; SELECT NOW();&#10;+---------------------+&#10;| NOW()               |&#10;+---------------------+&#10;| 2015-01-15 14:13:31 |&#10;+---------------------+&#10;1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="文本处理函数">文本处理函数</h4><ul>
<li>Upper() ,Left(),Length(),Locate(),Lower(),LTrim(),Right(),RTrim(),Soundex()<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, Upper(vend_name) AS vend_name_upcase&#10;FROM vendors&#10;ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="日期处理函数">日期处理函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AddDate()</td>
<td>增加一个日期（天，周等）</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间（时，分等）</td>
</tr>
<tr>
<td>curDate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期活时间串</td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>对于一个日期，返回对应星期几</td>
</tr>
<tr>
<td>Hour()</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td>Minute()</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td>Month()</td>
<td>返回一个日期的月部分</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期的时间</td>
</tr>
<tr>
<td>Second()</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>Year()</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody>
</table>
<p>日期格式：order_date =  2005-09-01 11:30:05<br>Date(order_date) = 2005-09-01 // 仅获取日期部分 (MySQL &gt;= 4.1.1)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id, order_num&#10;FROM orders &#10;WHERE Date(order_date) BETWEEN &#39;2005-09-01&#39; AND &#39;2005-09-30&#39;;&#10;&#10;(WHERE Year(order_date) = 2005 AND Month(order_date) = 9;)</span><br></pre></td></tr></table></figure>
<h4 id="数值处理函数">数值处理函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Abs()</td>
<td>返回一个数的绝对值</td>
</tr>
<tr>
<td>Cos()</td>
<td>返回一个角度的余弦</td>
</tr>
<tr>
<td>Exp()</td>
<td>返回一个数的指数值</td>
</tr>
<tr>
<td>Mod()</td>
<td>返回除操作的余数</td>
</tr>
<tr>
<td>Pi()</td>
<td>返回圆周率</td>
</tr>
<tr>
<td>Rand()</td>
<td>返回一个随机数</td>
</tr>
<tr>
<td>Sin()</td>
<td>返回一个角度的正弦</td>
</tr>
<tr>
<td>Sqrt()</td>
<td>返回一个数的平方根</td>
</tr>
<tr>
<td>Tan()</td>
<td>返回一个角度的正切</td>
</tr>
</tbody>
</table>
<h2 id="5个聚合函数">5个聚合函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVG()</td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>返回某列的行数</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列值的和</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(prod_price) AS avg_price&#10;FROM products&#10;WHERE vend_id = 1003;&#10;&#10;SELECT COUNT(*) AS num_cust&#10;FROM customers;&#10;&#10;SELECT COUNT(cust_email) AS num_cust&#10;FROM customers;&#10;&#10;SELECT MAX(prod_price) AS max_price&#10;FROM products;&#10;&#10;SELECT MIN(prod_price) AS min_price&#10;FROM products;&#10;&#10;SELECT SUM(quantity) AS items_orderd&#10;FROM orderitems&#10;WHERE order_num = 20005;&#10;&#10;SELECT SUM(item_price * quantity) AS total_price&#10;FROM orderitems&#10;WHERE order_num = 20005;&#10;&#10;//&#32858;&#21512;&#19981;&#21516;&#30340;&#20540;&#10;SELECT AVG(DISTINCT prod_price) AS avg_price&#10;FROM products&#10;WHERE vend_id = 1003;&#10;&#10;//&#32452;&#21512;&#32858;&#21512;&#20989;&#25968;&#10;SELECT COUNT(*) AS num_items,&#10;        MIN(prod_price) AS price_min,&#10;        MAX(prod_price) AS price_max,&#10;        AVG(prod_price) AS price_avg&#10;FROM products;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/3354490/" target="_blank" rel="external">MySQL 必知必会</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>本文梳理了MySQL的常用语法和操作，持续不断完善中…</p>
<h1 id="基本操作">基本操作</h1><h2 id="查看数据库详情">查看数据库详情</h2><figure class="highlight"><table><]]>
    </summary>
    
      <category term="MySQL" scheme="http://fengcode.com/tags/MySQL/"/>
    
      <category term="MySQL" scheme="http://fengcode.com/categories/MySQL/"/>
    
  </entry>
  
</feed>